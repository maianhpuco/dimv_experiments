---
title: "classification_experiement_v9 - implement DIMVf"
output:
  pdf_document: default
  html_document: default
date: "2022-09-30"
---


```{r setup, include = FALSE}
knitr::opts_chunk$set(cache = TRUE, echo=TRUE, eval = TRUE)
``` 


```{r}
require(knitr)
purl("imputation_v5.Rmd", output = 'imputation_v5.R')
```

```{r}
packages <- c(
  "missMDA", 
  "softImpute", 
  "caret", 
  "caTools", 
  "glue", 
  "jsonlite", 
  "future.apply", 
  "dslabs", 
  "cowplot", 
  "magick", 
  "progress", 
  "datasets", 
  "stats", 
  "foreach", 
  "fdm2id", 
  "datasetsICR", 
  "HDclassif", 
  "readxl", 
  "httr", 
  "doParallel"
)
# Install packages not yet installed
installed_packages <- packages %in% rownames(installed.packages())
if (any(installed_packages == FALSE)) {
  install.packages(packages[!installed_packages])
}

# Packages loading
invisible(lapply(packages, library, character.only = TRUE)) 

library(here) 
source(here('src/rscript/dimv.R'))  
source(here('src/rscript/dpers.R'))   
source(here('src/rscript/utils.R'))    
source(here('src/rscript/imputation_comparation.R'))     

plan(multisession, workers = 8)
library(doParallel)
registerDoParallel(cores=8) 
```

```{r}
read_excel_url <- function(url, sheet_num){
  GET(url, write_disk(tf <- tempfile(fileext = ".xls")))
  df <- read_excel(tf, sheet=2) 
  unlink(tf)
  return(df)
}
```

## Reading UCI dataset: 

```{r}
breast_tissue = read_excel_url('https://archive.ics.uci.edu/ml/machine-learning-databases/00192/BreastTissue.xls')
breast_tissue = subset(breast_tissue, select = -c(1) )
parkinsons = read.csv('http://archive.ics.uci.edu/ml/machine-learning-databases/parkinsons/parkinsons.data')
parkinsons = subset(parkinsons, select = -c(name) ) 
new_thyroid = read.csv('https://archive.ics.uci.edu/ml/machine-learning-databases/thyroid-disease/new-thyroid.data', header=F) 
breast_cancer_wisconsin = read.csv('https://archive.ics.uci.edu/ml/machine-learning-databases/breast-cancer-wisconsin/wdbc.data', header = F)
breast_cancer_wisconsin = subset(breast_cancer_wisconsin, select = -c(1) ) 

# ecoli = read.csv('https://archive.ics.uci.edu/ml/machine-learning-databases/ecoli/ecoli.data', header=F)
# ecoli = subset(ecoli, select = -c(1))
# ecoli
```

# ```{r}
# library(tscount)
# data(ecoli)
# ```


## Reading R dataset: 
```{r}
breast_tissue = as.data.frame(breast_tissue)
parkinsons = as.data.frame(parkinsons)
new_thyroid = as.data.frame(new_thyroid)
breast_cancer_wisconsin = as.data.frame(breast_cancer_wisconsin)


data(iris)
data(ionosphere)
data(seeds) 
data(wine)
```

```{r}
#GLOBAL VARIABLES
iris_conf                    = list("name" = "iris", "label_col" = "Species") 
ionosphere_conf              = list("name" = "ionosphere", "label_col" = "V35") 
seeds_conf                   = list("name" = "seeds", "label_col" = "variety") 
wine_conf                    = list("name" = "wine", "label_col" = "class") 


breast_tissue_conf           = list("name" = "breast_tissue", "label_col" = "Class")  
parkinsons_conf              = list("name" = "parkinsons", "label_col" = "status")  
new_thyroid_conf             = list("name" = "new_thyroid", "label_col" = "V1")  
breast_cancer_wisconsin_conf = list("name" = "breast_cancer_wisconsin", "label_col" = "V2")  
```

# Dataset list
```{r}
DATASETS = c("iris", "ionosphere", "seeds", "wine", "breast_tissue", "parkinsons", "new_thyroid", "breast_cancer_wisconsin")
```




# Utils 

```{r}
createRandomlyMissingData = function(data, rate){
  data = as.matrix(data)
  col_num = dim(data)[2] 
  flatten = as.vector(data) 
  
    
  mask = runif(length(flatten), min = 0, max = 1) < rate
  flatten[mask]=NaN
  return(matrix(flatten, ncol = col_num))
}
```

```{r, message = FALSE, warning = FALSE}
summary_result <- function(result, caclCol, groupByCol, fold_number, dataset_name, missing_rate, order_decreasing=TRUE){
  result$col = as.numeric(result[, caclCol]) 
  result$imputation  = result[, groupByCol]
  summary = data.frame(
                  group=levels(factor(result$imputation)), 
                  mean=(aggregate(result$col, by=list(result$imputation), FUN=mean)$x),
                  sd=(aggregate(result$col, by=list(result$imputation), FUN=sd)$x), 
                  iteration_times = max(result$fold_number)
             )
  summary = summary[order(summary$mean, decreasing=order_decreasing), ]   
  summary$dataset_name = dataset_name
  summary$missing_rate = missing_rate
  return(summary)
} 
``` 


```{r}
summary_all_result <- function(result, acc_col="accuracy", mse_train_col="rmse_train", mse_test_col="rmse_test", groupByCol="imputation_method", iteration="fold_number"){
  result$accuracy = as.numeric(result[, acc_col]) 
  result$rmse_train = as.numeric(result[, mse_train_col])
  result$rmse_test = as.numeric(result[, mse_test_col])
  
  result$imputation  = result[, groupByCol]
  
  summary = data.frame(
        group=levels(factor(result$imputation)), 
        
        accuracy_mean=(aggregate(result$accuracy, by=list(result$imputation), FUN=mean)$x),
        accuracy_sd=(aggregate(result$accuracy, by=list(result$imputation), FUN=sd)$x),  
        
        rmse_train_mean=(aggregate(result$rmse_train, by=list(result$imputation), FUN=mean)$x),
        rmse_train_sd=(aggregate(result$rmse_train, by=list(result$imputation), FUN=sd)$x), 
        
        rmse_test_mean=(aggregate(result$rmse_test, by=list(result$imputation), FUN=mean)$x),
        rmse_test_sd=(aggregate(result$rmse_test, by=list(result$imputation), FUN=sd)$x),  
        
        folds = max(result$fold_number)
         )
  
  summary = summary[order(summary$accuracy_mean, decreasing=T),]   
  summary$accuracy_ranking = rank(-summary$accuracy_mean)
  summary$mse_ranking = rank(summary$rmse_test_mean)
  return(summary)
}  

```



```{r}
imputeAndPredictionOnEachFold <- function(fold, missing_data, data, labels, folds, dataset_name, folder_name, DIMVthreshold){ 
  test_filter = unlist(unname(folds[fold])) 
  
  #filter fold's data 
  rmse_calc <- function(ori_data, imputed_rescaled_data,missing_pos_filter){
    nominator = sum((missing_pos_filter * ori_data - missing_pos_filter * imputed_rescaled_data)**2)
    denominator = sum(missing_pos_filter) 
    return(sqrt(nominator/denominator))
  }
  reconstructingNormedMatrix <- function(X_norm, mean, std){
    mult = sweep(X_norm, 2, std, '*')
    reconstrc = sweep(mult, 2, mean, '+')
    return (reconstrc)
  }
  labels = as.factor(labels)
  
  missing.X_train = missing_data[-test_filter, ] 
  missing.X_test = missing_data[test_filter, ]
  y.train = labels[-test_filter]
  y.test = labels[test_filter]  
  
  train_normed = normalizing(x=missing.X_train, Xtrain=missing.X_train)
  missing.X_train_normed = train_normed$X_normed
  missing.X_train_mean = train_normed$mean
  missing.X_train_sd = train_normed$sd 
  
  test_normed = normalizing(x=missing.X_test, Xtrain=missing.X_train)
  missing.X_test_normed = test_normed$X_normed 
  
  #saving Normalized misssing data
  curr_dir = getwd()
  if (dir.exists(file.path(root, dataset_name)) == F){
    dir.create(file.path(root, dataset_name))
  }
  
  if (dir.exists(file.path(root, dataset_name, folder_name))==F){
      dir.create(file.path(root, dataset_name, folder_name))
  }
  if (dir.exists(file.path(root, dataset_name, folder_name, fold))==F){
      dir.create(file.path(root, dataset_name, folder_name, fold))
  } 
  


  path.missing.X_train_normed = file.path(root, dataset_name, folder_name, fold,  "missing_X_train_normed.csv")
  path.missing.X_test_normed = file.path(root, dataset_name, folder_name, fold,  "missing_X_test_normed.csv") 
  path.missing.X_train_mean =  file.path(root, dataset_name, folder_name, fold,  "missing_X_train_mean.csv") 
  path.missing.X_train_sd = file.path(root, dataset_name, folder_name, fold,  "missing_X_train_sd.csv") 
  path.ori.X_train_ori = file.path(root, dataset_name, folder_name, fold, "ori_X_train.csv")
  path.ori.X_test_ori = file.path(root, dataset_name, folder_name, fold, "ori_X_test.csv")
  
  path.y_train = file.path(root, dataset_name, folder_name, fold, "y_train.csv")
  path.y_test = file.path(root, dataset_name, folder_name, fold, "y_test.csv")
   
  
  write.csv(missing.X_train_normed, path.missing.X_train_normed)
  write.csv(missing.X_test_normed, path.missing.X_test_normed)
  write.csv(missing.X_train_mean, path.missing.X_train_mean)
  write.csv(missing.X_train_sd, path.missing.X_train_sd)
  
  write.csv(data[-test_filter,,drop=F], path.ori.X_train_ori)
  write.csv(data[test_filter,,drop=F], path.ori.X_test_ori)
  
  write.csv(y.train, path.y_train)
  write.csv(y.test, path.y_test)
  
  
  
  func_list = list( 
    'impDi_run', 
    'softImpute_run', 
     'mice_run', 
    'imputePCA_run',  
    'kNNimpute_run', 
    'missForest_run'
    )   
    
  
  
  for(j in 1:length(func_list)){
    func_name = unlist(strsplit(func_list[[j]], "_run"))[1] 
  
    func <- get(func_list[[j]])  
    if (func_name == "impDi"){
      impted = func(missing.X_train_normed , y.train, missing.X_test_normed, y.test, threshold=DIMVthreshold)
    }else{
      impted = suppressWarnings(func(missing.X_train_normed , y.train, missing.X_test_normed, y.test))  
    }
    

    

#     print(which(rowSums(is.na(missing.X_train_normed))==dim(data)[2]))
#     print(which(rowSums(is.na(missing.X_test_normed))==dim(data)[2]))
    
    #fit an svm to the imputed data 
    fit.svm = suppressWarnings(train(as.data.frame(impted$train), y.train, method="svmRadial"))
    pred <- suppressWarnings((predict(fit.svm, as.data.frame(impted$test))))
    pred <- as.factor(pred)
    
    #calculate acc and rmse
    acc = mean(pred == y.test)
    rmse_train = rmse_calc(
            as.matrix(data[-test_filter,]), 
            reconstructingNormedMatrix(impted$train, missing.X_train_mean, missing.X_train_sd), 
            is.na(missing.X_train)*1 
            )
    rmse_test = rmse_calc(
            as.matrix(data[test_filter,]), 
            reconstructingNormedMatrix(impted$test, missing.X_train_mean, missing.X_train_sd),
            is.na(missing.X_test)*1 
            )
     
    
    result = data.frame( 
              list("dataset" = dataset_name, 
                    "fold_number" = fold, 
                    "imputation_method" =  func_name,
                    "accuracy" = acc,
                    "rmse_train" = rmse_train, 
                    "rmse_test" = rmse_test
              ) ) 
    
    if (j > 1){
        results = rbind(results, result)
    }else{
        results = result 
    }
  }
  return(results)
}
```


```{r}
imputeAndClassificationPipeline <- function(
    dataset, 
    dataset_name, 
    label_col, 
    DIMVthreshold, 
    root, 
    folder_name, 
    missing_rate, 
    number_of_folds){  
 
  data = dataset[, !names(dataset) %in% c(label_col)]  
  labels_origin = dataset[, label_col,drop=F ]

   #shuffle  
  shuffled_idx = sample(1:nrow(data))  
  data = data[shuffled_idx, ] 
  labels = as.numeric(factor(labels_origin[shuffled_idx, ]))   
  

  folds = createFolds(labels, k=number_of_folds)
  missing_data = createRandomlyMissingData(data, missing_rate)  
  
  allNANinRowsFound = length(which(rowSums(is.na(missing_data))==dim(data)[2])) > 0 

  if (allNANinRowsFound){
    print(length(which(rowSums(is.na(missing_data))==dim(data)[2])) )
    print(paste0("allNANinRowsFound = ", allNANinRowsFound, "_in_dataset", dataset_name))
    stop("found all NAN in Rows in missing data, try to sample again")
  } 
  
  
  pb <- txtProgressBar(min = 0, max = number_of_folds, style = 3)

  # results <- foreach::foreach(i = 1:number_of_folds, .combine='rbind') %dopar% {
  #   setTxtProgressBar(pb, i)
  #   imputeAndPredictionOnEachFold(i, missing_data, data, labels, folds, dataset_name, folder_name, DIMVthreshold)
  # }

  for (i in 1:number_of_folds){
    result = imputeAndPredictionOnEachFold(i, missing_data, data, labels, folds, dataset_name, folder_name, DIMVthreshold)
    setTxtProgressBar(pb, i)
    if (i == 1){
      results  = result
    }else{
      results = rbind(results, result)
    }
  }

  
  # SAVING ACCURACY AND RMSE FOR EACH FOLD
  results = data.frame(results)
  acc_summary = summary_result(results, 'accuracy', 'imputation_method', "fold_number", dataset_name, missing_rate, order_decreasing=T)
  rmse_test_summary = summary_result(results, 'rmse_test', 'imputation_method', "fold_number", dataset_name, missing_rate, order_decreasing=F)
  rmse_train_summary = summary_result(results, 'rmse_train', 'imputation_method', "fold_number", dataset_name,missing_rate,  order_decreasing=F)

  prediction_results = list("acc_summary" = acc_summary, "rmse_summary" = rmse_test_summary)


  curr_dir = getwd()
  if (dir.exists(file.path(root, dataset_name)) == F){
    dir.create(file.path(root, dataset_name))
  }

  if (dir.exists(file.path(root, dataset_name, folder_name))==F){
      dir.create(file.path(root, dataset_name, folder_name))
  }


# SAVING ACCURACY AND RMSE SUMMARY RESULT
  # FILE PATHS
  fold_results_dir = file.path(root, dataset_name, folder_name, "fold_results.csv")
  summary_acc_dir = file.path(root, dataset_name, folder_name, 'acc_summary.csv')
  summary_rmse_test_dir = file.path(root, dataset_name, folder_name, 'rmse_test_summary.csv')
  summary_rmse_train_dir = file.path(root, dataset_name, folder_name, 'rmse_train_summary.csv')


  # SAVING RESULT
  write.csv(results, fold_results_dir)
  write.csv(acc_summary, summary_acc_dir)
  write.csv(rmse_test_summary, summary_rmse_test_dir)
  write.csv(rmse_train_summary, summary_rmse_train_dir)
  print("done saving result")
  return(prediction_results)
} 
```




```{r}

executeImputeAndClassification <- function(root, DIMV_THRESHOLD, MISSING_RATE, NUM_FOLDS, DATASETS){
  
  formatFloat2String <- function(float_value){
    i = as.integer(float_value*100) 
    s = if (as.integer(i/10) < 1){paste0("0", toString(i))}else{toString(i)} 
    return(s)
  } 
  
  folder_name = paste0(
    "missing_rate_",
    formatFloat2String(MISSING_RATE), 
    "_threshold_", 
    formatFloat2String(DIMV_THRESHOLD)
    )
  
  
  print(folder_name)
  
  count = 0
  for (dataset_name in DATASETS) {
    print(paste0("dataset ", dataset_name))
    
    dataset_conf =  get(paste0(dataset_name, "_conf")) 
    dataset = get(dataset_name)
    label_col = dataset_conf$label_col 
    
    result = NULL 
    while(is.null(result)){
      try({
        result = imputeAndClassificationPipeline(
                      dataset,
                     	dataset_name,
                     	label_col,
                     	DIMV_THRESHOLD,
                     	root,
                     	folder_name,
                     	MISSING_RATE,
                     	NUM_FOLDS
                      )
        break #break/exit the for-loop
      }, silent = FALSE)
    }
  
  #   acc_summary = result$acc_summary
  #   rmse_summary = result$rmse_summary
  #   if (count==0){
  #     acc_summaries  = acc_summary
  #     rmse_summaries =  rmse_summary
  #   }else{
  #     acc_summaries  = rbind(acc_summaries, acc_summary)
  #     rmse_summaries =  rbind(rmse_summaries, rmse_summary)
  #   }
    # count = count + 1 
  }
  # 
  # curr_dir = getwd()
  # if (dir.exists(file.path(root, folder_name)) == F){
  #   dir.create(file.path(root, folder_name))
  # }


  # acc_dir = file.path(root, folder_name, "accuracy.csv")
  # rmse_dir = file.path(root, folder_name, "rmse.csv")
  # 
  # 
  # write.csv(acc_summaries, acc_dir)
  # write.csv(rmse_summaries, rmse_dir)
}

```


```{r}
root = "../../data/randomly_missing_dataset/svmRadial_20230116"

curr_dir = getwd()
if (dir.exists(file.path(root)) == F){
  dir.create(file.path(root))
}else{
  print('Root exists')
}

#DATASETS = ('new_thyroid')
#DATASETS = "new_thyroid"
DATASETS = c("iris", "ionosphere", "seeds", "wine", "breast_tissue", "new_thyroid", "breast_cancer_wisconsin")
#DATASETS = c("ionosphere", "seeds", "wine")
#DATASETS = c("iris", "ionosphere", "seeds", "wine", "breast_tissue", "new_thyroid", "breast_cancer_wisconsin")
#DATASETS = c("iris", "breast_tissue", "new_thyroid", "breast_cancer_wisconsin")
#DATASETS = c("iris", "breast_tissue", "parkinsons", "new_thyroid", "breast_cancer_wisconsin")
#DATASETS = c("iris")
NUM_FOLDS = 10

DIMV_THRESHOLD_LIST = c(.3)
MISSING_RATE_LIST = c(.5,.4,.3,.2,.1)
total = length(DIMV_THRESHOLD_LIST) * length(MISSING_RATE_LIST)

print(total)
count = 0
print(DATASETS)
print(MISSING_RATE_LIST)
print("==================================")
for (DIMV_THRESHOLD in DIMV_THRESHOLD_LIST){
  for (MISSING_RATE in MISSING_RATE_LIST){

    print(">>>>>>>>>>>>>>START--------------")
    print(paste0("MISSING_RATE_", MISSING_RATE, "_THRESHOLD_", DIMV_THRESHOLD , "_NUM_FOLDS_", NUM_FOLDS))

    executeImputeAndClassification(root, DIMV_THRESHOLD, MISSING_RATE, NUM_FOLDS, DATASETS)

    # repeat {
    # tmp<-try(
    #   executeImputeAndClassification(root, DIMV_THRESHOLD, MISSING_RATE, NUM_FOLDS, DATASETS)
    # )
    # if (!(inherits(tmp,"try-error")))
    #   break
    #   }


    count = count+1
    print(paste(">>>>>>>>>>>>>>>", count, "/", total, " done"))
  }
}


```

